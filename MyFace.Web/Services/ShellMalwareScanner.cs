using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace MyFace.Web.Services;

public class ShellMalwareScanner : IMalwareScanner
{
    private readonly ILogger<ShellMalwareScanner> _logger;
    private readonly IOptionsMonitor<MalwareScannerOptions> _options;

    public ShellMalwareScanner(ILogger<ShellMalwareScanner> logger, IOptionsMonitor<MalwareScannerOptions> options)
    {
        _logger = logger;
        _options = options;
    }

    public async Task<MalwareScanResult> ScanAsync(Stream stream, string fileName, CancellationToken cancellationToken = default)
    {
        var options = _options.CurrentValue;
        var stopwatch = Stopwatch.StartNew();

        if (!options.Enabled)
        {
            stopwatch.Stop();
            return MalwareScanResult.Skipped(options.EngineName, "Scanner disabled", stopwatch.Elapsed, false);
        }

        var workingDirectory = string.IsNullOrWhiteSpace(options.WorkingDirectory)
            ? Path.GetTempPath()
            : options.WorkingDirectory;
        Directory.CreateDirectory(workingDirectory);

        var tempPath = Path.Combine(workingDirectory, $"upload-scan-{Guid.NewGuid():N}");

        try
        {
            await using (var tempFile = File.Create(tempPath, 81920, FileOptions.Asynchronous))
            {
                await stream.CopyToAsync(tempFile, cancellationToken);
            }

            var arguments = string.IsNullOrWhiteSpace(options.Arguments)
                ? $"\"{tempPath}\""
                : $"{options.Arguments} \"{tempPath}\"";

            var startInfo = new ProcessStartInfo
            {
                FileName = options.Command,
                Arguments = arguments,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true,
                WorkingDirectory = workingDirectory
            };

            using var process = new Process { StartInfo = startInfo, EnableRaisingEvents = false };

            try
            {
                process.Start();
            }
            catch (Win32Exception ex)
            {
                stopwatch.Stop();
                var message = $"Scanner command '{options.Command}' could not be started: {ex.Message}";
                var available = ex.NativeErrorCode != 2;
                if (!available && options.FailOpenWhenUnavailable)
                {
                    _logger.LogWarning("Malware scanner unavailable, allowing upload.");
                    return MalwareScanResult.Skipped(options.EngineName, message, stopwatch.Elapsed, false);
                }

                _logger.LogError(ex, "Malware scanner failed to start.");
                return MalwareScanResult.Error(options.EngineName, message, stopwatch.Elapsed, available);
            }

            var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken);
            if (options.TimeoutSeconds > 0)
            {
                linkedCts.CancelAfter(TimeSpan.FromSeconds(options.TimeoutSeconds));
            }

            try
            {
                var stdOutTask = process.StandardOutput.ReadToEndAsync();
                var stdErrTask = process.StandardError.ReadToEndAsync();
                await process.WaitForExitAsync(linkedCts.Token);
                await Task.WhenAll(stdOutTask, stdErrTask);

                stopwatch.Stop();
                var raw = string.Join('\n', stdOutTask.Result, stdErrTask.Result).Trim();
                return ParseResult(options.EngineName, process.ExitCode, raw, stopwatch.Elapsed, fileName);
            }
            catch (OperationCanceledException)
            {
                TryKill(process);
                stopwatch.Stop();
                var timedOut = !cancellationToken.IsCancellationRequested;
                var message = timedOut
                    ? $"Scanner exceeded {options.TimeoutSeconds} seconds."
                    : "Scan canceled.";
                return MalwareScanResult.Error(options.EngineName, message, stopwatch.Elapsed, true);
            }
        }
        finally
        {
            try
            {
                if (File.Exists(tempPath))
                {
                    File.Delete(tempPath);
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Failed to clean up temp scan file {TempPath}", tempPath);
            }
        }
    }

    private static MalwareScanResult ParseResult(string engine, int exitCode, string rawOutput, TimeSpan duration, string fileName)
    {
        return exitCode switch
        {
            0 => MalwareScanResult.Clean(engine, rawOutput.Length == 0 ? "No threats detected." : rawOutput, duration),
            1 => MalwareScanResult.Malicious(engine,
                string.IsNullOrWhiteSpace(rawOutput) ? "Threat detected." : rawOutput,
                ExtractThreatName(rawOutput, fileName) ?? "Unknown",
                duration),
            _ => MalwareScanResult.Error(engine,
                string.IsNullOrWhiteSpace(rawOutput) ? $"Scanner exited with code {exitCode}." : rawOutput,
                duration,
                true)
        };
    }

    private static string? ExtractThreatName(string output, string fileName)
    {
        if (string.IsNullOrWhiteSpace(output))
        {
            return null;
        }

        var firstLine = output.Split('\n', StringSplitOptions.RemoveEmptyEntries).FirstOrDefault();
        if (string.IsNullOrWhiteSpace(firstLine))
        {
            return null;
        }

        var token = firstLine;
        var colonIndex = token.IndexOf(':');
        if (colonIndex >= 0)
        {
            token = token[(colonIndex + 1)..];
        }

        token = token.Replace("FOUND", string.Empty, StringComparison.OrdinalIgnoreCase).Trim();
        if (token.Equals(fileName, StringComparison.OrdinalIgnoreCase))
        {
            return null;
        }

        return string.IsNullOrWhiteSpace(token) ? null : token;
    }

    private static void TryKill(Process process)
    {
        try
        {
            if (!process.HasExited)
            {
                process.Kill(true);
            }
        }
        catch
        {
            // ignored
        }
    }
}
